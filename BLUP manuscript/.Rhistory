A_mat <- cov2cor(A_mat)
return(A_mat)
}
#####################################################################
#Simulate reaction norms
#####################################################################
#generate pedigree
#population properties
popmin=400
popmax=600
ngenerations = 10
nids<-sample(popmin:popmax, ngenerations, replace=TRUE) #N / generation
epm = sample(seq(0.15, 0.25,by=0.05),1) #extra-pair mating
nonb = sample(seq(0.4,0.6,by=0.05),1) #proportion of non-breeding / generation
#relatedness matrix
A_mat <- pedfun(popmin=popmin, popmax=popmax, ngenerations=ngenerations,
epm=epm, nonb=nonb, nids=nids, I=I)
#load required packages
library(Matrix); library(MASS); library(mvtnorm)
library(RANN); library(MCMCglmm); library(rstan)
#stan settings for compilation and parallel processing
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#####################################################################
#Parameter values
#####################################################################
I = 200 #total sample
Im = I/2 #total males
If = I/2 #total females
I_partner = 4 #partners/individual
I_obs = 2 #observations/individual/seasonalpartner
I_sample = I_partner*I_obs #samples/individual
N <-I*I_sample #total observations
N_sex<-N/2 #obs/sex
P <- 2 #P random effects (intercept, slope)
alpha_0AG = 0 #AG intercept
alpha_0FS = 0.3
psi_1 = 0.3 #regression coefficients
beta_n1 = -0.3
beta_s1 = -0.3
beta_s2 = -0.3
beta_d1 = -0.3
V = 0.3 #variance random effects
res_V = 0.3 #residual variance
r_G = 0.5 #cor between additive genetic RN components
r_E = -0.5 #cor between environmental RN components
r_O = -0.3 #cor between overdispersion
r_A = 0.2 #assortment cor between partners
#####################################################################
#Custom functions
#####################################################################
#simulate genetic correlation function (A matrix)
pedfun<-function(missing=NULL, popmin, popmax, ngenerations,
epm, nonb, nids, I){
# get list of individuals and their generations
gener<-1:ngenerations
genern <- rep(1:ngenerations, times = nids)
ID <- 1:sum(nids)
# runs on generation-by-generation basis
for(i in 1:ngenerations){
id<-ID[which(genern==i)]
dam<-rep(NA, nids[i])
sire<-rep(NA, nids[i])
# randomly allocates sex (0 = male, 1 = female)
sex<-sample(c(0,1), length(id), replace=TRUE)
# for first generation, no dams or sires are known
# so remain NA
if(i==1){
# combine into single data frame
pedigree<-data.frame(id=id, dam=dam, sire=sire,
generation=i, sex=sex)
}else if(i>1){
# for all generations after first
# list of all possible dams and sires
# from previous generation
pdams<-pedigree$id[which(pedigree$generation==(i-1) &
pedigree$sex==1)]
psires<-pedigree$id[which(pedigree$generation==(i-1) &
pedigree$sex==0)]
# determine number of pairs
# depending on how many males and females
# and the proportion of the population that is non-breeding
npairs<-min(length(pdams), length(psires)) -
round(min(length(pdams), length(psires))*nonb)
# selects breeding males and females
pdams<-pedigree$id[which(pedigree$generation==(i-1) &
pedigree$sex==1)]
psires<-pedigree$id[which(pedigree$generation==(i-1) &
pedigree$sex==0)]
if(length(pdams)<npairs | length(psires)<npairs){
npairs<-min(length(pdams), length(psires))
}
# selects pairs from possible dams and sires
pairs<-data.frame(dam=sample(pdams, npairs, replace=FALSE),
sire=sample(psires, npairs, replace=FALSE))
# gives each offspring their parental pair
pairid<-as.numeric(sample(rownames(pairs),
length(id), replace=TRUE))
# gives each offspring their sex
sex<-sample(c(0,1), length(id), replace=TRUE)
# put into dataframe format
addped<-data.frame(id=id,
dam=pairs$dam[pairid],
sire=pairs$sire[pairid],
generation=i,
sex=sex)
# deals with extra-pair mating (if included)
if(!is.null(epm)){
# for each individual, sample if they are extra pair
# if 0 not extra pair
# if 1 sire resampled from breeding population
# if 2 dam resampled
ext<-sample(c(0,1,2), nrow(addped),
replace=TRUE,
prob = c(1-epm, epm/2, epm/2))
for(j in 1:nrow(addped)){
if(ext[j]>0){
if(ext[j]==1){
addped$sire[j]<-sample(psires,1,replace=TRUE)
}else if (ext[j]==2){
addped$dam[j]<-sample(pdams,1,replace=TRUE)
}
}
}
}
# Deals with simulating missing data
# if this is specified
if(!is.null(missing)){
# determine if mother or father is missing
mis<-sample(c(0,1,2), nrow(addped),
replace=TRUE,
prob=c(1-missing, missing/2, missing/2))
for(j in 1:nrow(addped)){
if(mis[j]>0){
if(mis[j]==1){
addped$dam[j]<-NA
}else if(mis[j]==2){
addped$sire[j]<-NA
}
}
}
}
# add new generation to the whole pedigree
pedigree<-rbind(pedigree, addped)
}
}
ped <- pedigree
# make id's non-numeric
ped$id<-paste("ID",ped$id, sep="")
ped$dam[which(!is.na(ped$dam))]<-paste("ID",ped$dam[which(!is.na(ped$dam))], sep="")
ped$sire[which(!is.na(ped$sire))]<-paste("ID",ped$sire[which(!is.na(ped$sire))], sep="")
ped$id<-as.character(ped$id)
ped$dam<-as.character(ped$dam)
ped$sire<-as.character(ped$sire)
IDs <- sample(ped[ped$generation==ngenerations, "id"], I, replace=FALSE)
ped <- MCMCglmm::prunePed(ped, keep = IDs, make.base=TRUE)
inv.phylo <- MCMCglmm::inverseA(ped[,c("id","dam","sire")])
A <- solve(inv.phylo$Ainv)
A <- cov2cor(A)
A = (A + t(A))/2 # Not always symmetric after inversion
A <- as.matrix(A)
rownames(A) <- rownames(inv.phylo$Ainv)
colnames(A) <- rownames(inv.phylo$Ainv)
#subset to final generation
A_sub<-A[IDs,IDs]
A_mat <- as.matrix(nearPD(A_sub)$mat)
A_mat <- cov2cor(A_mat)
return(A_mat)
}
#####################################################################
#Simulate reaction norms
#####################################################################
#generate pedigree
#population properties
popmin=400
popmax=600
ngenerations = 10
nids<-sample(popmin:popmax, ngenerations, replace=TRUE) #N / generation
epm = sample(seq(0.15, 0.25,by=0.05),1) #extra-pair mating
nonb = sample(seq(0.4,0.6,by=0.05),1) #proportion of non-breeding / generation
#relatedness matrix
A_mat <- pedfun(popmin=popmin, popmax=popmax, ngenerations=ngenerations,
epm=epm, nonb=nonb, nids=nids, I=I)
#Random effect correlations
G_cor <- matrix(c(1,r_G,r_G,1), nrow=2, ncol=2) #A0, A1
G_sd  <- c(sqrt(V),sqrt(V)) #G effect sds
G_cov <- diag(G_sd) %*% G_cor %*% diag(G_sd)
E_cor <- matrix(c(1,r_E,r_E,1), nrow=2, ncol=2) #E0, E1
E_sd  <- c(sqrt(V),sqrt(V)) #E effect sds
E_cov <- diag(E_sd) %*% E_cor %*% diag(E_sd)
install.packages('bookdown')
install.packages(c("backports", "bayesplot", "BDgraph", "BH", "broom", "callr", "cli", "clipr", "clusterGeneration", "coda", "colorspace", "colourpicker", "covr", "crayon", "crosstalk", "data.table", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "expm", "fansi", "fastmap", "fdrtool", "forcats", "Formula", "future", "generics", "ggplot2", "ggraph", "ggrepel", "ggridges", "gh", "git2r", "globals", "glue", "graphlayouts", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "inline", "isoband", "jsonlite", "knitr", "labeling", "loo", "lubridate", "magick", "magrittr", "matrixStats", "memoise", "mgcv", "mime", "mnormt", "mvnfast", "openssl", "pbapply", "phytools", "pillar", "pkgbuild", "plotrix", "processx", "promises", "ps", "psych", "qgraph", "R6", "Rcpp", "RcppArmadillo", "RcppEigen", "readr", "rematch2", "remotes", "reprex", "reshape2", "rex", "rlang", "rmarkdown", "roxygen2", "rprojroot", "rstudioapi", "rversions", "scales", "shiny", "shinyjs", "shinythemes", "stringi", "sys", "testthat", "tibble", "tidygraph", "tidyr", "tidyselect", "tinytex", "usethis", "vctrs", "withr", "xfun", "xml2", "xts", "zoo"), lib="\\files.iem.uzh.ch/Data/Institute/Human_Ecology/jormar/Private/My Documents/R/win-library/3.6")
install.packages(c("arsenal", "backports", "bayesplot", "BH", "boot", "bridgesampling", "broom", "callr", "car", "checkmate", "class", "cli", "clipr", "cluster", "coda", "codetools", "colorspace", "colourpicker", "cowplot", "crayon", "crosstalk", "curl", "data.table", "digest", "doParallel", "DT", "ellipsis", "fansi", "fastmap", "forcats", "foreach", "future", "generics", "geomorph", "GGally", "ggplot2", "ggridges", "ggstance", "globals", "gratia", "gtools", "haven", "hms", "htmltools", "htmlwidgets", "httpuv", "igraph", "inline", "isoband", "iterators", "jsonlite", "jtools", "KernSmooth", "knitr", "labeling", "later", "listenv", "lme4", "magrittr", "maptools", "MASS", "Matrix", "matrixStats", "mgcv", "mice", "mime", "mvnfast", "nlme", "nloptr", "nnet", "openssl", "openxlsx", "pbkrtest", "pillar", "pkgbuild", "pkgload", "plyr", "prettyunits", "processx", "promises", "ps", "quantreg", "R6", "RcppArmadillo", "RcppEigen", "readr", "rgl", "rmarkdown", "rprojroot", "RRPP", "rsconnect", "scales", "shiny", "shinyjs", "shinythemes", "sp", "spatial", "statmod", "stringi", "survival", "sys", "testthat", "threejs", "tibble", "tidyr", "tinytex", "xfun", "xts", "yaml", "zip", "zoo"), lib="C:/Program Files/R/R-3.6.0/library")
.libPaths("C:/Program Files/R/R-3.6.0/library")
m.repeatmoms <- readRDS("C:/LHT Basel/m.repeatmoms.RDS")
memory.limit()
1e5
memory.limit(size = 1e5)
#load combined file
m.rmom <- readRDS("C:/LHT Basel/m.repeatmoms.RDS")
#load packages
library(rstan)
options(mc.cores = parallel::detectCores())
#increase memory for loading large file
memory.limit(size = 1e5)
#load combined file
m.rmom <- readRDS("C:/LHT Basel/m.repeatmoms.RDS")
#load packages
library(rstan); library(brms); library(shinystan)
launch_shinystan(m.rmom)
install.packages("cachem")
update.packages("cachem")
#load packages
library(mvtnorm)
library(rstan)
library(shinystan)
## increase memory to avoid crashing with loop
memory.limit(size=100000)
#set directory
setwd("C:/Temp/BLUPs/BLUP manuscript")
#Stan settings
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
#simulation parameters
cor = 0.3 #RN correlations
sd = sqrt(0.3) #RN standard deviation
beta = 0.3
res = sqrt(0.5) #observation-level residual variance
popint = 0 #population RN intercept
popslope = 0 #population RN slope
popdisp = sqrt(0.5) #population RN dispersion
I = 100 #number of individuals
repm = 3 #repeated behavioral measures
#simulation algorithms
sim_p = function(cor,sd,beta,res,popint,popslope,popdisp,N,repm){
#RN parameters
#cors = sample(c(cor, -1*cor), size=3*3, replace=TRUE) #random sign
#R = matrix(cors, nrow=3, ncol=3 )
#R[lower.tri(R)] = t(R)[lower.tri(R)] #force symmetric
#diag(R) = 1
#S = matrix( c(sd,0,0,0,sd,0,0,0,sd), nrow=3, ncol=3 )
#P = S %*% R %*% S
#z_p = rmvnorm(I, mean = rep(0,3), sigma = P)
z_p = rnorm(I, mean = 0, sd = sd)
personality = z_p
#plasticity = z_p[,2]
#predictability = z_p[,3]
#environmental covariate (z-score)
x = rnorm(I*repm, 0, 1)
#behavioral response model
ind = rep(1:I, each = repm) #index of repeated individual measures
popslope = sample(c(popslope, -1*popslope),size=1) #random sign
z_mu = popint + personality[ind] #+ (popslope + plasticity[ind])*x
#z_sigma = log(popdisp) + predictability[ind]
#z = rnorm(I*repm, mean = z_mu, sd = exp(z_sigma) )
z = rnorm(I*repm, mean = z_mu, sd = popdisp )
#beta coefficients
betas = sample(c(beta, -1*beta), size=3, replace=TRUE)
#fitness response model
w_mu = 1 + cbind(personality) * betas[1] +
betas[2]*(personality^2) #betas[5]*(plasticity^2)+betas[6]*(predictability^2)+
#betas[7]*(personality*plasticity)+betas[8]*(personality*predictability)+
#betas[9]*(plasticity*predictability)
w = rnorm(I, mean = w_mu, sd = res)
data = list(x = x, z = z, w = w, ind = ind, I = I, N = I*repm, betas = betas)
return(data)
}
sim_pp = function(cor,sd,beta,res,popint,popslope,popdisp,N,repm){
#RN parameters
cors = sample(c(cor, -1*cor), size=2*2, replace=TRUE) #random sign
R = matrix(cors, nrow=2, ncol=2 )
R[lower.tri(R)] = t(R)[lower.tri(R)] #force symmetric
diag(R) = 1
S = matrix( c(sd,0,0,sd), nrow=2, ncol=2)
P = S %*% R %*% S
z_p = rmvnorm(I, mean = rep(0,2), sigma = P)
personality = z_p[,1]
plasticity = z_p[,2]
#predictability = z_p[,3]
#environmental covariate (z-score)
x = rnorm(I*repm, 0, 1)
#behavioral response model
ind = rep(1:I, each = repm) #index of repeated individual measures
popslope = sample(c(popslope, -1*popslope),size=1) #random sign
z_mu = popint + personality[ind] + (popslope + plasticity[ind])*x
#z_sigma = popdisp + predictability[ind]
z = rnorm(I*repm, mean = z_mu, sd = popdisp )
#beta coefficients
betas = sample(c(beta, -1*beta), size=5, replace=TRUE)
#fitness response model
w_mu = 1 + cbind(personality,plasticity) %*% betas[1:2] +
betas[3]*(personality^2) + betas[4]*(plasticity^2)#+betas[6]*(predictability^2)+
betas[5]*(personality*plasticity)#+betas[8]*(personality*predictability)+
#betas[9]*(plasticity*predictability)
w = rnorm(I, mean = w_mu, sd = res)
data = list(x = x, z = z, w = w, ind = ind, I = I, N = I*repm, R = R, betas = betas)
return(data)
}
sim_ppp = function(cor,sd,beta,res,popint,popslope,popdisp,N,repm){
#RN parameters
cors = sample(c(cor, -1*cor), size=3*3, replace=TRUE) #random sign
R = matrix(cors, nrow=3, ncol=3 )
R[lower.tri(R)] = t(R)[lower.tri(R)] #force symmetric
diag(R) = 1
S = matrix( c(sd,0,0,0,sd,0,0,0,sd), nrow=3, ncol=3 )
P = S %*% R %*% S
z_p = rmvnorm(I, mean = rep(0,3), sigma = P)
personality = z_p[,1]
plasticity = z_p[,2]
predictability = z_p[,3]
#environmental covariate (z-score)
x = rnorm(I*repm, 0, 1)
#behavioral response model
ind = rep(1:I, each = repm) #index of repeated individual measures
popslope = sample(c(popslope, -1*popslope),size=1) #random sign
z_mu = popint + personality[ind] + (popslope + plasticity[ind])*x
z_sigma = log(popdisp) + predictability[ind]
z = rnorm(I*repm, mean = z_mu, sd = exp(z_sigma) )
#beta coefficients
betas = sample(c(beta, -1*beta), size=9, replace=TRUE)
#fitness response model
w_mu = 1 + cbind(personality,plasticity,predictability) %*% betas[1:3] +
betas[4]*(personality^2)+betas[5]*(plasticity^2)+betas[6]*(predictability^2)+
betas[7]*(personality*plasticity)+betas[8]*(personality*predictability)+
betas[9]*(plasticity*predictability)
w = rnorm(I, mean = w_mu, sd = res)
data = list(x = x, z = z, w = w, ind = ind, I = I, N = I*repm, R = R, betas = betas)
return(data)
}
#simulate dataset
sim_p(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
sim_pp(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
sim_ppp(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
#simulate dataset
sim_p(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
sim_pp(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
sim_ppp(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
#simulate dataset
sim_p(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
##########################################
#Personality only, N 100, 3
##########################################
I = 100; repm = 3; sim = 200
df.p100.3 = list()
for(i in 1:sim){df.p100.3[[i]] =
sim_p(cor,sd,beta,res,popint,popslope,popdisp,N,repm) }
saveRDS(df.p100.3, "df_p100_3.RDS")
df.pl100_2
df.pl100_3
df.p100_3
df.p100.3
#load packages
library(mvtnorm)
#library(rstan)
#library(shinystan)
## increase memory to avoid crashing with loop
memory.limit(size=100000)
#set directory
setwd("C:/Users/jormar/Dropbox/Selection-on-RNs/BLUP manuscript")
#Stan settings
options(mc.cores = parallel::detectCores())
rstan::rstan_options(auto_write = TRUE)
#simulation parameters
cor = 0.3 #RN correlations
sd = sqrt(0.3) #RN standard deviation
beta = 0.3
res = sqrt(0.5) #observation-level residual variance
popint = 0 #population RN intercept
popslope = 0 #population RN slope
popdisp = sqrt(0.5) #population RN dispersion
I = 100 #number of individuals
repm = 3 #repeated behavioral measures
#simulation algorithms
sim_p = function(cor,sd,beta,res,popint,popslope,popdisp,N,repm){
#RN parameters
z_p = rnorm(I, mean = 0, sd = sd)
personality = z_p
#environmental covariate (z-score)
x = rnorm(I*repm, 0, 1)
#behavioral response model
ind = rep(1:I, each = repm) #index of repeated individual measures
z_mu = popint + personality[ind]
z = rnorm(I*repm, mean = z_mu, sd = popdisp )
#beta coefficients
betas = sample(beta, size=2, replace=TRUE)
#fitness response model
w_mu = 1 + personality * betas[1] +  betas[2]*(personality^2)
w = rnorm(I, mean = w_mu, sd = res)
data = list(x = x, z = z, w = w, ind = ind, I = I, N = I*repm, betas = betas)
return(data)
}
sim_pp = function(cor,sd,beta,res,popint,popslope,popdisp,N,repm){
#RN parameters
cors = sample(c(cor, -1*cor), size=2*2, replace=TRUE) #random sign
R = matrix(cors, nrow=2, ncol=2 )
R[lower.tri(R)] = t(R)[lower.tri(R)] #force symmetric
diag(R) = 1
S = matrix( c(sd,0,0,sd), nrow=2, ncol=2)
P = S %*% R %*% S
z_p = rmvnorm(I, mean = rep(0,2), sigma = P)
personality = z_p[,1]
plasticity = z_p[,2]
#environmental covariate (z-score)
x = rnorm(I*repm, 0, 1)
#behavioral response model
ind = rep(1:I, each = repm) #index of repeated individual measures
z_mu = popint + personality[ind] + (popslope + plasticity[ind])*x
z = rnorm(I*repm, mean = z_mu, sd = popdisp )
#beta coefficients
betas = sample(beta, size=5, replace=TRUE)
#fitness response model
w_mu = 1 + cbind(personality,plasticity) %*% betas[1:2] +
betas[3]*(personality^2) + betas[4]*(plasticity^2)+
betas[5]*(personality*plasticity)
w = rnorm(I, mean = w_mu, sd = res)
data = list(x = x, z = z, w = w, ind = ind, I = I, N = I*repm, R = R, betas = betas)
return(data)
}
sim_ppp = function(cor,sd,beta,res,popint,popslope,popdisp,N,repm){
#RN parameters
cors = sample(c(cor, -1*cor), size=3*3, replace=TRUE) #random sign
R = matrix(cors, nrow=3, ncol=3 )
R[lower.tri(R)] = t(R)[lower.tri(R)] #force symmetric
diag(R) = 1
S = matrix( c(sd,0,0,0,sd,0,0,0,sd), nrow=3, ncol=3 )
P = S %*% R %*% S
z_p = rmvnorm(I, mean = rep(0,3), sigma = P)
personality = z_p[,1]
plasticity = z_p[,2]
predictability = z_p[,3]
#environmental covariate (z-score)
x = rnorm(I*repm, 0, 1)
#behavioral response model
ind = rep(1:I, each = repm) #index of repeated individual measures
z_mu = popint + personality[ind] + (popslope + plasticity[ind])*x
z_sigma = log(popdisp) + predictability[ind]
z = rnorm(I*repm, mean = z_mu, sd = exp(z_sigma) )
#beta coefficients
betas = sample(beta, size=9, replace=TRUE)
#fitness response model
w_mu = 1 + cbind(personality,plasticity,predictability) %*% betas[1:3] +
betas[4]*(personality^2)+betas[5]*(plasticity^2)+betas[6]*(predictability^2)+
betas[7]*(personality*plasticity)+betas[8]*(personality*predictability)+
betas[9]*(plasticity*predictability)
w = rnorm(I, mean = w_mu, sd = res)
data = list(x = x, z = z, w = w, ind = ind, I = I, N = I*repm, R = R, betas = betas)
return(data)
}
#simulate dataset
sim_p(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
sim_pp(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
sim_ppp(cor,sd,beta,res,popint,popslope,popdisp,N,repm)
I = 500; repm = 3; sim = 200
df.pp500.3 = list()
for(i in 1:sim){
df.pp500.3[[i]] = sim_pp(cor,sd,beta,res,popint,popslope,popdisp,N,repm) }
saveRDS(df.pp500.3, "df_pp500_3.RDS")
#compile Stan model
mod = rstan::stan_model(file="gaus_pp.stan")
#MCMC settings
n_iter <- 2000
n_warm <- 1000
n_chains <- 4
#dataframe for results
pp500.3_pw = data.frame(iter = seq(1:sim), pb1 = NA, pb2 = NA, pb3 = NA, pb4 = NA, pb5 = NA)
#estimate models
for(i in 1:sim){
df = df.pp500.3[[i]]
est_mod <- rstan::sampling(mod, data=df, init="0", iter=n_iter, warmup=n_warm, seed = i,
chains=n_chains, cores=n_chains, control=list(adapt_delta=0.99, max_treedepth=10))
#posterior samples
post = rstan::extract(est_mod)
#selection gradients
betas = data.frame(post[grepl("betas", names(post)) ] )
pp500.3_pw[i,"pb1"] = sum(sign(df$betas[1])==sign(betas[,1]))/length(betas[,1])
pp500.3_pw[i,"pb2"] = sum(sign(df$betas[2])==sign(betas[,2]))/length(betas[,2])
pp500.3_pw[i,"pb3"] = sum(sign(df$betas[3])==sign(betas[,3]))/length(betas[,3])
pp500.3_pw[i,"pb4"] = sum(sign(df$betas[4])==sign(betas[,4]))/length(betas[,4])
pp500.3_pw[i,"pb5"] = sum(sign(df$betas[5])==sign(betas[,5]))/length(betas[,5])
saveRDS(pp500.3_pw,"pp500_3pw.RDS")
}
apply(pp500.3_pw, 2, function(x) sum(x>0.95)/length(x))
I = 500; repm = 6; sim = 200
df.pp500.6 = list()
for(i in 1:sim){
df.pp500.6[[i]] = sim_pp(cor,sd,beta,res,popint,popslope,popdisp,N,repm) }
saveRDS(df.pp500.6, "df_pp500_6.RDS")
#compile Stan model
mod = rstan::stan_model(file="gaus_pp.stan")
#MCMC settings
n_iter <- 2000
n_warm <- 1000
n_chains <- 4
#dataframe for results
pp500.6_pw = data.frame(iter = seq(1:sim), pb1 = NA, pb2 = NA, pb3 = NA, pb4 = NA, pb5 = NA)
#estimate models
for(i in 1:sim){
df = df.pp500.6[[i]]
est_mod <- rstan::sampling(mod, data=df, init="0", iter=n_iter, warmup=n_warm, seed = i,
chains=n_chains, cores=n_chains, control=list(adapt_delta=0.99, max_treedepth=10))
#posterior samples
post = rstan::extract(est_mod)
#selection gradients
betas = data.frame(post[grepl("betas", names(post)) ] )
pp500.6_pw[i,"pb1"] = sum(sign(df$betas[1])==sign(betas[,1]))/length(betas[,1])
pp500.6_pw[i,"pb2"] = sum(sign(df$betas[2])==sign(betas[,2]))/length(betas[,2])
pp500.6_pw[i,"pb3"] = sum(sign(df$betas[3])==sign(betas[,3]))/length(betas[,3])
pp500.6_pw[i,"pb4"] = sum(sign(df$betas[4])==sign(betas[,4]))/length(betas[,4])
pp500.6_pw[i,"pb5"] = sum(sign(df$betas[5])==sign(betas[,5]))/length(betas[,5])
saveRDS(pp500.6_pw,"pp500_6pw.RDS")
}
apply(pp500.6_pw, 2, function(x) sum(x>0.95)/length(x))
